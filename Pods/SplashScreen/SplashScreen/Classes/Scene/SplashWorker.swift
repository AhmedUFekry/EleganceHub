//
//  SplashWorker.swift
//  SmartMic
//
//  Created by Marcel Mendes Filho on 09/08/19.
//  Copyright (c) 2019 Marcel Mendes Filho. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

class SplashWorker
{
    func getSplash(app: String,
                   version: String,
                   key: String,
                   localization: String,
                   hostName: String,
                   splashEndpoint: String,
                   httpHeader: String,
                   completion: @escaping (Bool, Splash?, String?) -> Void){
        
        let postURL = URL(string: "\(httpHeader)\(hostName)\(splashEndpoint)")!
        var postRequest = URLRequest(url: postURL, cachePolicy: .reloadIgnoringLocalAndRemoteCacheData, timeoutInterval: 60.0)
        
        postRequest.httpMethod = "POST"
        postRequest.setValue("application/x-www-form-urlencoded", forHTTPHeaderField: "Content-Type")
        postRequest.setValue("application/json", forHTTPHeaderField: "Accept")
        
        let parameters: [String: Any] = [
            "key": key,
            "app": app,
            "localization": localization,
            "version": version
        ]
        
        postRequest.httpBody = parameters.percentEscaped().data(using: .utf8)
        
        let sessionConfig = URLSessionConfiguration.default
        let session = URLSession(configuration: sessionConfig)
        
        session.dataTask(with: postRequest) { (data, response, error) in
            if let receivedResponse = response as? HTTPURLResponse{
                
                if receivedResponse.statusCode == 200{
                    if let data = data, let splash = SplashHelper.decode(jsonData: data){
                        completion(true, splash, nil)
                    } else {
                        completion(false, nil, "Could not decode splash.")
                    }
                } else {
                    completion(false, nil, "HTTP status code: \(receivedResponse.statusCode)")
                    return
                }
            } else {
                completion(false, nil, error?.localizedDescription)
                return
            }
            }.resume()
        
    }

    func getData(from url: URL, completion: @escaping (Data?, URLResponse?, Error?) -> ()) {
        URLSession.shared.dataTask(with: url, completionHandler: completion).resume()
    }
    
    func downloadImage(iconName: String,
                       httpHeader: String,
                       imageHostName: String,
                       imagePath: String,
                       completion: @escaping (UIImage?, Error?) -> Void){
        if let url = URL(string: "\(httpHeader)\(imageHostName)\(imagePath)\(iconName)"){
            getData(from: url) { data, response, error in
                guard let data = data, error == nil else {
                    completion(nil, error)
                    return
                }
                completion(UIImage(data: data), nil)
            }
        } else {
            let error = NSError(domain: "", code: 0, userInfo: [:])
            completion(nil, error)
        }
    }
}
